<!DOCTYPE HTML>
<html class="no-js" lang="zh-CN">

<head>
    <!--[if lte IE 9]>
<meta http-equiv="refresh" content="0;url=http://yoursite.com/warn.html">
<![endif]-->
<meta charset="utf-8">

<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">
<meta http-equiv="mobile-agent" content="format=html5; url=http://yoursite.com">
<meta name="author" content="">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/SimpleStyle.min.css">

<link rel="shortcut icon" href="/images/favicon.png">


<title>深入浅出讲算法思想--分治法思想分析及应用 - 无关--私人IT技术博客</title>

<meta name="keywords" content="">

<meta name="description " content="数据结构与算法--JAVA">
</head>
<body>
<div id="nav">
    <nav class="nav-menu">
        <a class="site-name current" href="/" title="锐">锐</a>
        <a class="site-index current" href="/"><i class="fa fa-home"></i><span>首页</span></a>
        <a href="/archives" title="归档"><i class="fa fa-archives"></i><span>归档</span></a>
        <a href="/tags" title="标签"><i class="fa fa-tags"></i><span>标签</span></a>
        <!-- custom single page of menus -->
        
        
        <a href="/help" title="帮助">
            <i class="fa fa-question-circle"></i>
            <span>帮助</span>
        </a>
        
    </nav>
</div>

<div class="nav-user">
    <a class="btn-search" href="#"><i class="fa fa-search"></i></a>
    <a class="btn-read-mode" href="#"><i class="fa fa-sun-o"></i></a>
    <a class="btn-sns-qr" href="javascript:"><i class="fa fa-telegram"></i></a>
</div>

<div id="wrapper" class="clearfix">
    <div id="body">
        <div class="main" id="main">
            <div id="cover">
    <div class="cover-img"></div>
    <div class="cover-info">
        
        <h1 class="cover-siteName">牧</h1>
        <h3 class="cover-siteTitle">不跟风，不动摇</h3>
        <p class="cover-siteDesc">做技术总是要辛苦些的</p>
        <div class="cover-sns">
            
            <div class="btn btn-qq">
                <a href="" target="_blank" title="qq" ref="friend">
                    <i class="fa fa-qq"></i>
                </a>
            </div>
            
            <div class="btn btn-weibo">
                <a href="https://weibo.com/u/5213426541" target="_blank" title="weibo" ref="friend">
                    <i class="fa fa-weibo"></i>
                </a>
            </div>
            
            <div class="btn btn-weixin">
                <a href="" target="_blank" title="weixin" ref="friend">
                    <i class="fa fa-weixin"></i>
                </a>
            </div>
            
            <div class="btn btn-github">
                <a href="https://github.com/2585479524" target="_blank" title="github" ref="friend">
                    <i class="fa fa-github"></i>
                </a>
            </div>
            
        </div>
    </div>
</div>
            <div class="page-title">
    <ul>
        <li><a href="/">最新</a></li>
        
            
                <li class="">
                    <a href="/categories/big-front-end" data-name="前端">前端</a>
                </li>
            
                <li class="active">
                    <a href="/categories/serverSide" data-name="后端">后端</a>
                </li>
            
                <li class="">
                    <a href="/categories/unity" data-name="Unity">Unity</a>
                </li>
            
                <li class="">
                    <a href="/categories/resource" data-name="曾经沧海">曾经沧海</a>
                </li>
            
        
        <li class="page-search">
    <form id="search" class="search-form">
        <label for="s" class="sr-only">请输入关键字</label>
        <input class="search-field" type="text" name="s" class="text" placeholder="请输入关键字" />
        <button type="submit" class="search-form-submit" title="搜索"><i class="fa fa-search"></i></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="不用搜索了，这是假的"/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
</li>

    </ul>
</div>
<div class="main-inner">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
        <div class="post-header">
            <div class="post-author clearfix">
                <a class="avatar fleft" href="" target="_blank">
                    <img width="48" src="/images/favicon.png" alt="avatar"/>
                </a>
                <p><span class="label">作者</span>
                    <a href="" target="_blank">牧</a>
                    <span title="最后编辑于2018-05-05">2018-05-05</span>
                </p>
                <p>会点前端的游戏开发者</p>
            </div>
            <h2 class="post-title">深入浅出讲算法思想--分治法思想分析及应用</h2>
            <div class="post-meta">
                本文总共20095个字 | 您是第<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>位看到它们的小伙伴
            </div>
        </div>
        <div class="post-content markdown-body">
            <ol>
<li>分治法在排序算法中的应用–归并排序</li>
<li>分治法在排序算法中的应用–快速排序(Lomuto划分、Hoare划分、随机化快排)</li>
<li>分治法在二叉树遍历中的应用–二叉查找树高度、树的遍历</li>
<li>分治法在求解”最近对”问题中的应用</li>
<li>分治法在求解凸包问题中的应用–快包算法</li>
</ol>
<h2 id="一、分治法在排序算法中的应用–归并排序"><a href="#一、分治法在排序算法中的应用–归并排序" class="headerlink" title="一、分治法在排序算法中的应用–归并排序"></a>一、分治法在排序算法中的应用–归并排序</h2><p>分治法最常用的就是将规模为n的实例划分成两个n规模为n/2的实例 。推广到一般的情况，我们可以将规模为n的实例划分为b个规模为n/b的实例。这样对于算法的运行时间存在递推式：T(n) = aT（n/b）+f（n），这个式子又被称为通用分治递推式。</p>
<p>我们假定递推式中的f(n)∈O(n^d)，其中d&gt;=0，那么：</p>
<p><img src="/img/2018/divideAndConquerSummaryInJava/1.png" alt="1"><br>所以，对于等分的T(n) = 2T(n/2) + 1,因为a=2,b=2,d=0,并且a &gt; b^d</p>
<p>则T(n) = O(n);</p>
<p>上面这个式子就是用来求解递推式结果的。</p>
<p><strong>归并排序：</strong>(时间复杂度O(nlogn))</p>
<p>对于一个需要排序的数组a[0 - n-1]，先将数组一分为二a[0 - n/2-1]和a[n/2+1 - n]，对子数组排序，之后合并为一个有序数组</p>
<p>import java.util.Arrays;</p>
<p>public class Main {</p>
<pre><code>public static void merge(int[] a, int low, int mid, int high) {
    int[] temp = new int[high - low + 1];
    int i = low;// 左指针
    int j = mid + 1;// 右指针
    int k = 0;
    // 把较小的数先移到新数组中
    while (i &lt;= mid &amp;&amp; j &lt;= high) {
        if (a[i] &lt; a[j]) {
            temp[k++] = a[i++];
        } else {
            temp[k++] = a[j++];
        }
    }
    // 把左边剩余的数移入数组
    while (i &lt;= mid) {
        temp[k++] = a[i++];
    }
    // 把右边边剩余的数移入数组
    while (j &lt;= high) {
        temp[k++] = a[j++];
    }
    // 把新数组中的数覆盖a数组
    for (int k2 = 0; k2 &lt; temp.length; k2++) {
        a[k2 + low] = temp[k2];
    }
}

public static void mergeSort(int[] a, int low, int high) {
    int mid = (low + high) / 2;
    if (low &lt; high) {
        // 左边
        mergeSort(a, low, mid);
        // 右边
        mergeSort(a, mid + 1, high);
        // 左右归并
        merge(a, low, mid, high);
        System.out.println(Arrays.toString(a));
    }

}

public static void main(String[] args) {
    int[] a = {8, 3, 2, 9, 7, 1, 5, 4};
    mergeSort(a, 0, a.length - 1);
    System.out.println(&quot;排序结果：&quot; + Arrays.toString(a));
}
</code></pre><p>}</p>
<p>归并排序在最坏情况下的键值比较次数十分接近基于比较的排序算法在理论上能够达到的最少次数。<br>此外快速排序和堆排序的时间复杂度也是O(nlogn)，但是相比来说，归并排序在于其<a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7/9763250?fr=aladdin" target="_blank" rel="noopener">稳定性</a></p>
<h2 id="二、分治法在排序算法中的应用-JAVA-–快速排序-Lomuto划分、Hoare划分、随机化快排"><a href="#二、分治法在排序算法中的应用-JAVA-–快速排序-Lomuto划分、Hoare划分、随机化快排" class="headerlink" title="二、分治法在排序算法中的应用(JAVA)–快速排序(Lomuto划分、Hoare划分、随机化快排)"></a>二、分治法在排序算法中的应用(JAVA)–快速排序(Lomuto划分、Hoare划分、随机化快排)</h2><p><strong>快速排序：</strong>时间复杂度O(nlogn)</p>
<p>如果说归并排序是按照元素在数组中的位置划分的话，那么快速排序就是按照元素的值进行划分。划分方法由两种，本节将主要介绍Huare划分，在<a href="/2018/05/05/decreaseAndConquerSummaryInJava">深入浅出讲算法思想–减治法思想分析及应用</a>这篇文章的第二部分中讲述了Lomuto划分用于快速查找算法，下面不再赘述，仅给出基于Lomuto的快排代码。</p>
<p><strong>1. 基于Lomuto划分的快速排序算法</strong><br>public class Main {<br>    static int[] a= {5, 3, 1, 9, 8, 2, 4, 7};<br>    public static void main(String[] args) {<br>        fastsort(0, a.length-1);<br>        for (int i = 0; i &lt; a.length; i++) {<br>            System.out.print(a[i] + “ “);<br>        }<br>    }</p>
<pre><code>private static int Lomuto(int l, int r) {
    int p = a[l];
    int s = l;
    for (int i = l+1; i &lt;= r; i++) {
        if (a[i] &lt; p) {
            s = s+1;
            int temp = a[s];
            a[s] = a[i];
            a[i] = temp;
        }
    }
    int temp = a[l];
    a[l] = a[s];
    a[s] = temp;
    return s;
}
    private static void fastsort(int l, int r) {
        if (l &lt; r) {
            int s = Lomuto(l, r);
            fastsort(l, s-1);
            fastsort(s+1, r);
        }
    }
</code></pre><p>}<br><strong>2、基于Hoare划分的快速排序</strong></p>
<p>Hoare划分是一种更为复杂的划分方式，我们假设有一个数组a[0, n-1],其子数组为a<a href="0 &lt;= l &lt;= r &lt;= n-1">l, r</a>,假定首个元素为枢轴p，下面从数组两端进行扫描，并将扫描到的元素与枢轴比较。从左到右扫描（用指针i来表示），扫描到第一个大于等于枢轴p的，停止；从右到左扫描（用指针j表示，遇到第一个小于等于枢轴的元素）。这里注意等于枢轴的元素也要进行处理，这样可以保证数组分的更加平均。如果遇到相等元素继续扫描，对于一个具有n个相同元素的数组来说，划分后得到的两个子数组长度可能为n-1和0。</p>
<p>两侧的扫描都停止之后，根据扫描指针是否相交会有三种情况：若 i &lt; j，则交换a[i]与a[j]，i+1，j-1；若 i &gt; j，交换a[p]与a[j]；若i = j，则交换a[p]与a[j]。眼尖的读者估计看出来了，后两种情况其实是一种。</p>
<p>下图为Hoare划分的示意图：<br><img src="/img/2018/divideAndConquerSummaryInJava/3.png" alt="示意图"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    static int[] a= &#123;5, 3, 1, 9, 8, 2, 4, 7&#125;;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        fastsort(0, a.length-1);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int Hoare(int l, int r) &#123;</span><br><span class="line">        int p = a[l];</span><br><span class="line">        int i = l-1;</span><br><span class="line">        int j = r+1 ;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; while (a[j] &gt; p);</span><br><span class="line"></span><br><span class="line">            do &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; while (a[i] &lt; p);</span><br><span class="line"></span><br><span class="line">            if (i &lt; j) &#123;</span><br><span class="line">                int temp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">            &#125; else</span><br><span class="line">                return j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static void fastsort(int l, int r) &#123;</span><br><span class="line">        if (l &lt; r) &#123;</span><br><span class="line">            int s = Hoare(l, r);</span><br><span class="line">            fastsort(l, s);</span><br><span class="line">            fastsort(s+1, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/2018/divideAndConquerSummaryInJava/4.png" alt="示意图"><br>一般来说，如果我们要考虑一个算法的实用性，我们需要讨论的不是最坏情况下的效率，而应该是平均情况下的效率。实际经过分析，快速排序平均情况下的操作仅比最优情况多执行39%的比较过程而已。所以在处理随机序列时，速度要强于归并排序和堆排序。</p>
<p>缺点：快速排序并非稳定性排序方式，空间复杂度为O(logn)，不及堆排序的空间复杂度O(1).</p>
<p>提出问题：对于数组非常小的情况下（对于大多数计算机来说，元素个数为5-15），使用插入排序会更快</p>
<p>解决思路1：判断元素个数，较小时采用插入排序，较大时采用快速排序。</p>
<p>解决思路2：不再对划分出来的较小数组排序，而是在快速排序结束后再使用插入排序的方法对整个接近有序的数组进行细微调节。</p>
<p>提出问题：如果我们每次都选取第一个元素为枢轴，这自然会有诸多不便，不能应对一些特殊的情况。</p>
<p>解决思路：随机化快速排序、三平均划分法，下面给出代码，基本思想还是划分，有兴趣的读者可以研究一下。</p>
<p><strong>3. 随机化快排：</strong>使用随机元素作为枢轴。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    static int[] a= &#123;5, 3, 1, 9, 8, 2, 4, 7&#125;;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        fastsort(0, a.length-1);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static int random_partition(int l, int r) &#123;</span><br><span class="line">        int i = (int) (l + Math.random() % (r - l + 1));</span><br><span class="line">        int temp = a[i];</span><br><span class="line">        a[i] = a[r];</span><br><span class="line">        a[r] = temp;</span><br><span class="line">        return partition(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    private static int partition(int l, int r) &#123;</span><br><span class="line"></span><br><span class="line">        int p = a[r];</span><br><span class="line">        int i = l - 1;</span><br><span class="line">        for (int j = l; j &lt; r; j++) &#123;</span><br><span class="line">            if (a[j] &lt;= p) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                int temp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int temp = a[i+1];</span><br><span class="line">        a[i+1] = a[r];</span><br><span class="line">        a[r] = temp;</span><br><span class="line">        return i+1;</span><br><span class="line">    &#125;</span><br><span class="line">    private static void fastsort(int l, int r) &#123;</span><br><span class="line">        if (l &lt; r) &#123;</span><br><span class="line">            int s = random_partition(l, r);</span><br><span class="line">            random_partition(l, s-1);</span><br><span class="line">            random_partition(s+1, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4. 三平均划分法快排：</strong>以最左元素、最右元素、最中间元素的中位数为枢轴。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    static int[] a= &#123;5, 3, 1, 9, 8, 2, 4, 7&#125;;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        fastsort(0, a.length-1);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int mid_partition(int l, int r)</span><br><span class="line">    &#123;</span><br><span class="line">        int range = r - l + 1;</span><br><span class="line">        int mid1 = (int) (l + Math.random() % range);</span><br><span class="line">        int mid2 = (int) (l + Math.random() % range);</span><br><span class="line">        int mid3 = (int) (l + Math.random() % range);</span><br><span class="line">        int mid  = (a[mid1] &lt; a[mid2]) ?</span><br><span class="line">                (a[mid2] &lt; a[mid3] ? mid2 : (a[mid1] &lt; a[mid3] ? mid3 : mid1)):</span><br><span class="line">                (a[mid1] &lt; a[mid3] ? mid1 : (a[mid2] &lt; a[mid3] ? mid2 : mid3));</span><br><span class="line">        int temp = a[mid];</span><br><span class="line">        a[mid] = a[r];</span><br><span class="line">        a[r] = temp;</span><br><span class="line">        return partition(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    private static int partition(int l, int r) &#123;</span><br><span class="line">        int p = a[r];</span><br><span class="line">        int i = l - 1;</span><br><span class="line">        for (int j = l; j &lt; r; j++) &#123;</span><br><span class="line">            if (a[j] &lt;= p) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                int temp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int temp = a[i+1];</span><br><span class="line">        a[i+1] = a[r];</span><br><span class="line">        a[r] = temp;</span><br><span class="line">        return i+1;</span><br><span class="line">    &#125;</span><br><span class="line">        private static void fastsort(int l, int r) &#123;</span><br><span class="line">            if (l &lt; r) &#123;</span><br><span class="line">                int s = mid_partition(l, r);</span><br><span class="line">                fastsort(l, s-1);</span><br><span class="line">                fastsort(s+1, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>提出问题：在划分方式上Lomuto划分和Hoare划分也可以进行改进，使用诸如三路划分的方式，将数组划分3段，每段元素分别小于、等于、大于枢轴元素等等。当然，这些就仅供研究学习了，平时我们使用最简单版本的快速排序是没有任何问题的。</p>
<h2 id="三、分治法在二叉树遍历中的应用–二叉查找树高度、树的遍历"><a href="#三、分治法在二叉树遍历中的应用–二叉查找树高度、树的遍历" class="headerlink" title="三、分治法在二叉树遍历中的应用–二叉查找树高度、树的遍历"></a>三、分治法在二叉树遍历中的应用–二叉查找树高度、树的遍历</h2><p>二叉树本身就是由两个更小的部分组成–左子树和右子树，所以二叉树的问题非常适合用分治法来解决。</p>
<p><strong>二叉树的高度：</strong>从叶子到根之间的最长路径。我们可以理解为根的左子树高度和右子树高度加1（加1代表根所在的层）。</p>
<p>定义空树的高度为-1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static int height(Node node) &#123;</span><br><span class="line">    if (node == null) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return Math.max(height(node.l), height(node.r)) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T(n) = T(left) + T(right) + 1由递推式可得时间复杂度为O(n)</p>
<p><strong>二叉树遍历：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 先序遍历</span><br><span class="line">     * */</span><br><span class="line">    private static void preorder(Node node) &#123;</span><br><span class="line">        System.out.print(node.v + &quot; &quot;);</span><br><span class="line">        if (node.l != null)</span><br><span class="line">            preorder(node.l);</span><br><span class="line">        if (node.r != null)</span><br><span class="line">            preorder(node.r);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 中序遍历</span><br><span class="line">     * */</span><br><span class="line">    private static void midorder(Node node) &#123;</span><br><span class="line">        if (node.l != null)</span><br><span class="line">            preorder(node.l);</span><br><span class="line">        System.out.print(node.v + &quot; &quot;);</span><br><span class="line">        if (node.r != null)</span><br><span class="line">            preorder(node.r);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 后序遍历</span><br><span class="line">     * */</span><br><span class="line">    private static void nextorder(Node node) &#123;</span><br><span class="line">        if (node.l != null)</span><br><span class="line">            preorder(node.l);</span><br><span class="line">        if (node.r != null)</span><br><span class="line">            preorder(node.r);</span><br><span class="line">        System.out.print(node.v + &quot; &quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>完整代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    int v;</span><br><span class="line">    Node l;</span><br><span class="line">    Node r;</span><br><span class="line"></span><br><span class="line">    public Node(int v) &#123;</span><br><span class="line">        this.v = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static Node root;</span><br><span class="line"></span><br><span class="line">    private static int height(Node node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(height(node.l), height(node.r)) + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean insert(Node node) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            if (node.v &gt; cur.v) &#123;</span><br><span class="line">                if (cur.r == null) &#123;</span><br><span class="line">                    cur.r = node;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.r;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (cur.l == null) &#123;</span><br><span class="line">                    cur.l = node;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 先序遍历</span><br><span class="line">     * */</span><br><span class="line">    private static void preorder(Node node) &#123;</span><br><span class="line">        System.out.print(node.v + &quot; &quot;);</span><br><span class="line">        if (node.l != null)</span><br><span class="line">            preorder(node.l);</span><br><span class="line">        if (node.r != null)</span><br><span class="line">            preorder(node.r);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 中序遍历</span><br><span class="line">     * */</span><br><span class="line">    private static void midorder(Node node) &#123;</span><br><span class="line">        if (node.l != null)</span><br><span class="line">            preorder(node.l);</span><br><span class="line">        System.out.print(node.v + &quot; &quot;);</span><br><span class="line">        if (node.r != null)</span><br><span class="line">            preorder(node.r);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 后序遍历</span><br><span class="line">     * */</span><br><span class="line">    private static void nextorder(Node node) &#123;</span><br><span class="line">        if (node.l != null)</span><br><span class="line">            preorder(node.l);</span><br><span class="line">        if (node.r != null)</span><br><span class="line">            preorder(node.r);</span><br><span class="line">        System.out.print(node.v + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 插入</span><br><span class="line">         * */</span><br><span class="line">        insert(new Node(20));</span><br><span class="line">        insert(new Node(10));</span><br><span class="line">        insert(new Node(30));</span><br><span class="line">        /**</span><br><span class="line">         * 前序遍历</span><br><span class="line">         * */</span><br><span class="line">        preorder(root);</span><br><span class="line">        nextorder(root);</span><br><span class="line">        midorder(root);</span><br><span class="line">        System.out.println(height(root));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，并非所有关于二叉树的算法都需要遍历两颗子树，诸如二叉树的查找、插入、删除操作只需要遍历其中一棵，有兴趣的读者可以参考<a href="/2018/05/05/decreaseAndConquerSummaryInJava">深入浅出讲算法思想–减治法思想分析及应用</a>这篇文章的第三部分。</p>
<p>关于二叉树感兴趣的朋友还可以继续学习<a href="https://www.jianshu.com/p/0190985635eb" target="_blank" rel="noopener">一篇文章搞定面试中的二叉树题目(java实现)</a></p>
<h2 id="四、分治法在求解“最近对”问题中的应用"><a href="#四、分治法在求解“最近对”问题中的应用" class="headerlink" title="四、分治法在求解“最近对”问题中的应用"></a>四、分治法在求解“最近对”问题中的应用</h2><p>最近对问题在蛮力法中有过讲解，时间复杂度为O(n^2)，下面将会采用分治法讲解这类问题，时间复杂度会降到O(nlogn)</p>
<p>我们将笛卡尔平面上n&gt;1个点构成的集合称为P。若2&lt;= n &lt;= 3时，我们1可以通过蛮力法求解。但当n&gt;3时，采用分治法或许是个更好的选择。假设这些点是按照x轴、y轴升序排列的，可以找出点集在x轴方向上的中位数m，做一条垂直x轴的分割线，由此点将点集划分为左右两个大小为n/2的子集P1和P2，之后通过递归求解出在子集中的最近对距离d1，d2，最后找出d=max{d1，d2}。</p>
<p>但是！！！不巧的是，我们忽略了一个问题，如果距离最近的两个点刚好分别在两个子集中，那么d就不是所有点对的最小距离。我们需要在每次合并子问题结果时，要加以判断是否存在这样的点对。方法是：只考虑以分割线为对称轴、宽度为2d的垂直带中的的点，因为其他点对的距离都是大于d的。</p>
<p><strong>这里给出一个优化，当我们在垂直带中找到一个点p，只需要考虑p之后的5个点即可。</strong></p>
<p>这是因为：如果我们在垂直带中找到p-p’两点的距离小于p，由于我们的序列时经过排序的，所以p’一定在p之后，且两点在y轴上的距离一定是小于d的（根据勾股定理，两点之间的距离如果小于d，那么x轴分量和y轴分量都是小于d的，反之，不可能存在这个点）。所以在几何学上，p’的位置一定在下图中的淡黄色矩形区域。而矩形区域内一般只能包含少量的候选点，这个数量最大为6（根据鸽巢定理）。图中6个红色点为极端的临界情况。我们将d <em> 2d的矩形划分为d/2 </em> 2d/3的6块区域，如果超过6个点，假设为7，那么一定会出现某个小矩形中有两个点，这两个点的最大距离为图中红线距离5/6d&lt;d，这和d的意义不符。<br><img src="/img/2018/divideAndConquerSummaryInJava/5.png" alt="示意图"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">class Point &#123;</span><br><span class="line">    double x;</span><br><span class="line">    double y;</span><br><span class="line">    Point (double x, double y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    static Point[] point;</span><br><span class="line">    static Point[] minP = new Point[2];</span><br><span class="line">    static Scanner in = new Scanner(System.in);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int n = in.nextInt();</span><br><span class="line">        point = new Point[n];</span><br><span class="line">//        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">//            int a = in.nextInt();</span><br><span class="line">//            int b = in.nextInt();</span><br><span class="line">//            point[i] = new Point(a, b);</span><br><span class="line">//        &#125;</span><br><span class="line">        point[0] = new Point(1,3);</span><br><span class="line">        point[1] = new Point(2,1);</span><br><span class="line">        point[2] = new Point(3,5);</span><br><span class="line">        point[3] = new Point(4,4);</span><br><span class="line">        point[4] = new Point(5,2);</span><br><span class="line">        Arrays.sort(point,0, n, new Comparator&lt;Point&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Point o1, Point o2) &#123;</span><br><span class="line">                return (int) (o1.x - o2.x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(point.length);</span><br><span class="line">        double minD = closestPoint(0, point.length-1);</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            System.out.println(minP[i].x + &quot;,&quot; + minP[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(minD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static double closestPoint(int low, int high) &#123;</span><br><span class="line">        Point[] temp1 = new Point[2];</span><br><span class="line">        Point[] temp2 = new Point[2];</span><br><span class="line">        Point[] p = new Point[high - low + 1];</span><br><span class="line">        double d, d1, d2, d3;</span><br><span class="line">        int index = 0;</span><br><span class="line">        if (high - low == 1) &#123;</span><br><span class="line">            minP[0] = new Point(point[low].x, point[low].y);</span><br><span class="line">            minP[1] = new Point(point[high].x, point[high].y);</span><br><span class="line">            return distance(point[low], point[high]);</span><br><span class="line">        &#125;</span><br><span class="line">        if (high - low == 2) &#123;</span><br><span class="line">            d1 = distance(point[low], point[low+1]);</span><br><span class="line">            d2 = distance(point[low+1], point[high]);</span><br><span class="line">            d3 = distance(point[low], point[high]);</span><br><span class="line">            if ((d1 &lt;= d2) &amp;&amp; (d1 &lt;= d3)) &#123;</span><br><span class="line">                minP[0] = new Point(point[low].x, point[low].y);</span><br><span class="line">                minP[1] = new Point(point[low+1].x, point[low+1].y);</span><br><span class="line">                return d1;</span><br><span class="line">            &#125; else if (d2 &lt;= d3) &#123;</span><br><span class="line">                minP[0] = new Point(point[low+1].x, point[low+1].y);</span><br><span class="line">                minP[1] = new Point(point[high].x, point[high].y);</span><br><span class="line">                return d2;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                minP[0] = new Point(point[low].x, point[low].y);</span><br><span class="line">                minP[1] = new Point(point[high].x, point[high].y);</span><br><span class="line">                return d3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (low + high) / 2;</span><br><span class="line">        d1 = closestPoint(low, mid);</span><br><span class="line">        temp1[0] = minP[0];</span><br><span class="line">        temp1[1] = minP[1];</span><br><span class="line">        d2 = closestPoint(mid+ 1, high);</span><br><span class="line">        temp2[0] = minP[0];</span><br><span class="line">        temp2[1] = minP[1];</span><br><span class="line">        if (d1 &lt; d2) &#123;</span><br><span class="line">            d = d1;</span><br><span class="line">            minP[0] = temp1[0];</span><br><span class="line">            minP[1] = temp1[1];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            d = d2;</span><br><span class="line">            minP[0] = temp2[0];</span><br><span class="line">            minP[1] = temp2[1];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = mid;i&gt;=low &amp;&amp; (point[mid].x - point[i].x) &lt; d; i--) &#123;</span><br><span class="line">            p[index++] = point[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = mid+1;i&lt;=high &amp;&amp; (point[i].x - point[mid].x) &lt; d; i++) &#123;</span><br><span class="line">            p[index++] = point[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(p, 0, index, new Comparator&lt;Point&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Point o1, Point o2) &#123;</span><br><span class="line">                return (int) (o1.y - o2.y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        for (int i = 0; i &lt; index-1; i++) &#123;</span><br><span class="line">            for (int j = i+1; j &lt; index; j++) &#123;</span><br><span class="line">                if ((p[j].y - p[i].y) &gt;= d) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    d3 = distance(p[i], p[j]);</span><br><span class="line">                    if (d3 &lt; d) &#123;</span><br><span class="line">                        minP[0] = new Point(p[i].x, p[i].y);</span><br><span class="line">                        minP[1] = new Point(p[j].x, p[j].y);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static double distance(Point p1, Point p2) &#123;</span><br><span class="line">        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/2018/divideAndConquerSummaryInJava/6.png" alt="示意图"><br>Input：<br>5</p>
<p>Output：</p>
<p>4.0,4.0<br>3.0,5.0<br>1.4142135623730951</p>
<p>五、分治法在求解凸包问题中的应用–快包算法</p>
<p>分治法在求解凸包问题中的应用（JAVA）<br>之前写过一篇<a href="/2018/05/05/violenceSummaryInJava">深入浅出讲算法思想–蛮力法思想分析及应用</a>其中的第二部分讲述了蛮力求解凸包问题的思想，没有基础的读者最好先去阅读以下。<br>这里用分治法来求解凸包问题，由于这个算法和快速排序十分相似，因此又被称为“快包”。<br>在平面上有n&gt;1个点构成的集合，定义为S，为简化思考，假定这些点按照x轴、y轴升序排列。有一个几何事实就是，最左边的一个点p1和最右边的一个点pn一定是集合的凸包顶点。我们连接p1与pn，这条直线将所有的点分成了两个子集合S1，S2。如果p1，p2，p3构成一个逆时针回路，我们称p3为与直线p1-p2的左侧；反之，称为p3为与直线p1-p2的右侧。另外S集合中位于p1-p2直线上的点，肯定不是凸包的顶点，直接忽略不考虑。<br><img src="/img/2018/divideAndConquerSummaryInJava/7.png" alt="示意图"><br>S的凸包边界是有上下两条多角形链条组成的，“上”边界称为上包，上包由p1、S1（如果S1不为空）中的一些点、p2为端点组成，“下”边界称为下包，下包由p1、S2（如果S2不为空）中的一些点、p2为端点组成。上下端点用同样的方法构造而成，采用分治法思路更为清晰。下面以上包为例，分析所谓的快包算法：<br><img src="/img/2018/divideAndConquerSummaryInJava/8.png" alt="示意图"></p>
<p>由于一些下标不好表示，这里截取了《算法设计与分析基础》中的文字讲解部分。<br>知道了原来，我们该如何实现呢？假设我们有三个点p1（x1, x1）, p2(x2, y2)，p3(x3, y3)，这三点围成的三角形的面积可以用下面的公式计算：<br><img src="/img/2018/divideAndConquerSummaryInJava/9.png" alt="示意图"><br>当且仅当p3位于直线p1-p2左侧时，该表达式符号为正。<br>和快速排序一样，该算法的最差时间复杂度为O(n^2)，但是平均效率好很多！<br>下面的代码在精度上由于采用double类型，但是没有做判断上的处理，比如比较大小的时候，所以对于高精度的数据并不适用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">class Point &#123;</span><br><span class="line">    double x;</span><br><span class="line">    double y;</span><br><span class="line"></span><br><span class="line">    public Point(double x, double y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    static Point[] point;</span><br><span class="line">    static double[] s = new double[6];</span><br><span class="line">    static Scanner in = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int n = in.nextInt();</span><br><span class="line">        point = new Point[n];</span><br><span class="line">//        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">//            int a = in.nextInt();</span><br><span class="line">//            int b = in.nextInt();</span><br><span class="line">//            point[i] = new Point(a, b);</span><br><span class="line">//        &#125;</span><br><span class="line">        point[0] = new Point(1,3);</span><br><span class="line">        point[1] = new Point(2,1);</span><br><span class="line">        point[2] = new Point(3,5);</span><br><span class="line">        point[3] = new Point(4,4);</span><br><span class="line">        point[4] = new Point(5,2);</span><br><span class="line">        point[5] = new Point(3,2);</span><br><span class="line">        Arrays.sort(point,0, n, new Comparator&lt;Point&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Point o1, Point o2) &#123;</span><br><span class="line">                if (o1.x - o2.x == 0) &#123;</span><br><span class="line">                    return (int) (o1.y - o2.y);</span><br><span class="line">                &#125;</span><br><span class="line">                return (int) (o1.x - o2.x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(point[0].x + &quot;,&quot; + point[0].y);</span><br><span class="line">        hull(1, n-1,point[0],point[0]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void hull(int l,int r,Point p1,Point p2)&#123;</span><br><span class="line">        int x=l;</span><br><span class="line">        int i=l-1,j=r+1;</span><br><span class="line">        /**</span><br><span class="line">         * 找出距离直线p1-p2最远的点p3</span><br><span class="line">         * */</span><br><span class="line">        for (int k = l; k &lt;= r; k++)&#123;</span><br><span class="line">            if (s[x] - s[k] &lt;= 0) &#123;</span><br><span class="line">                x=k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Point p3 = point[x];</span><br><span class="line">        /**</span><br><span class="line">         * p1-p3左侧的点</span><br><span class="line">         * */</span><br><span class="line">        for (int k = l; k &lt;= r; k++) &#123;</span><br><span class="line"></span><br><span class="line">            s[++i] = cross(point[k], p1, p3);</span><br><span class="line">            if (s[i] &gt; 0) &#123;</span><br><span class="line">                Point temp = point[i];</span><br><span class="line">                point[i] = point[k];</span><br><span class="line">                point[k] = temp;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">         * 直线p3-p2右侧的点</span><br><span class="line">         * */</span><br><span class="line">        for (int k=r;k&gt;=l;k--) &#123;</span><br><span class="line">            s[--j]=cross(point[k], p3, p2);</span><br><span class="line">            if (s[j] &gt; 0) &#123;</span><br><span class="line">                Point temp = point[j];</span><br><span class="line">                point[j] = point[k];</span><br><span class="line">                point[k] = temp;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">         * 分治，并中序输出</span><br><span class="line">         * */</span><br><span class="line">        if (l &lt;= i) &#123;</span><br><span class="line">            hull(l, i, p1, p3);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(p3.x + &quot;,&quot; + p3.y);</span><br><span class="line">        if (j &lt;= r) &#123;</span><br><span class="line">            hull(j, r, p3, p2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static double cross (Point a, Point b, Point c) &#123;</span><br><span class="line">        return (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        </div>
        <div class="post-tool">
            <a class="btn-thumbs-up" href="javascript:void(0);" data-cid="52" title="95">
                <i class="fa fa-thumbs-up" aria-hidden="true"></i> 打赏
            </a>
        </div>
        
        <div class="post-tags">标签：
            
            <a href="/tags/算法思想/">算法思想</a>
            
        </div>
        
    </article>
    
    <p>文章为原创作品，转发请留言</p>
    
    
</div>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        </div><!-- end #main-->
    </div><!-- end #body -->
    <footer class="footer">
    <div class="footer-inner">
        <p>
            <a href="/about"  title="关于本站">关于本站</a>&nbsp;&nbsp;<em>·</em>&nbsp;&nbsp;
            <!-- 自定义链接 -->
            <a href="http://www.iroha.ltd" title="help" >大佬的网站</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <!-- <a href="/links" title="友情链接">友情链接</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/app" title="App下载">App下载</a> -->
        </p>
        <p>
            本站点采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>，已建立<a href="/timeline" id="siteBuildingTime"></a>天<br/>
            ©copyright 2018 <a href="http://blog.rebright.top" target="_blank">REBRIGHT</a><br>
            <span><a href="http://www.miitbeian.gov.cn" target="_blank">鲁ICP备17050989号</a></span>
            <span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=37028102000217" target="_blank">鲁ICP备17050989号</a></span>
        </p>
        
        
<!-- Tencent Analytics -->
<script type="text/javascript" src="//tajs.qq.com/stats?sId=65823874" charset="UTF-8"></script>


    </div>
</footer>
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>
<script src="/js/InsightSearch.js"></script>
<script src="/js/SimpleCore.js"></script>

</div>
<div class="fixed-btn">
    <a class="btn-gotop" href="javascript:"> <i class="fa fa-angle-up"></i></a>
</div>
<script>
    $(function () {
        SimpleCore.init({
            buildingTime: '01/26/2018',
            current: $('.post-tags').length > 0 ? 'post' : 'archive',
            snsQRCode: '/images/sns-qrcode.png',
            donateImg: '/images/donate-qr.png',
        });
    });
</script>
</body>
</html>
