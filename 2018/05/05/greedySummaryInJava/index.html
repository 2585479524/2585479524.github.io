<!DOCTYPE HTML>
<html class="no-js" lang="zh-CN">

<head>
    <!--[if lte IE 9]>
<meta http-equiv="refresh" content="0;url=http://yoursite.com/warn.html">
<![endif]-->
<meta charset="utf-8">

<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">
<meta http-equiv="mobile-agent" content="format=html5; url=http://yoursite.com">
<meta name="author" content="">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/SimpleStyle.min.css">

<link rel="shortcut icon" href="/images/favicon.png">


<title>深入浅出讲算法思想--贪婪法思想分析及应用 - 无关--私人IT技术博客</title>

<meta name="keywords" content="">

<meta name="description " content="数据结构与算法--JAVA">
</head>
<body>
<div id="nav">
    <nav class="nav-menu">
        <a class="site-name current" href="/" title="锐">锐</a>
        <a class="site-index current" href="/"><i class="fa fa-home"></i><span>首页</span></a>
        <a href="/archives" title="归档"><i class="fa fa-archives"></i><span>归档</span></a>
        <a href="/tags" title="标签"><i class="fa fa-tags"></i><span>标签</span></a>
        <!-- custom single page of menus -->
        
        
        <a href="/help" title="帮助">
            <i class="fa fa-question-circle"></i>
            <span>帮助</span>
        </a>
        
    </nav>
</div>

<div class="nav-user">
    <a class="btn-search" href="#"><i class="fa fa-search"></i></a>
    <a class="btn-read-mode" href="#"><i class="fa fa-sun-o"></i></a>
    <a class="btn-sns-qr" href="javascript:"><i class="fa fa-telegram"></i></a>
</div>

<div id="wrapper" class="clearfix">
    <div id="body">
        <div class="main" id="main">
            <div id="cover">
    <div class="cover-img"></div>
    <div class="cover-info">
        
        <h1 class="cover-siteName">牧</h1>
        <h3 class="cover-siteTitle">不跟风，不动摇</h3>
        <p class="cover-siteDesc">做技术总是要辛苦些的</p>
        <div class="cover-sns">
            
            <div class="btn btn-qq">
                <a href="" target="_blank" title="qq" ref="friend">
                    <i class="fa fa-qq"></i>
                </a>
            </div>
            
            <div class="btn btn-weibo">
                <a href="https://weibo.com/u/5213426541" target="_blank" title="weibo" ref="friend">
                    <i class="fa fa-weibo"></i>
                </a>
            </div>
            
            <div class="btn btn-weixin">
                <a href="" target="_blank" title="weixin" ref="friend">
                    <i class="fa fa-weixin"></i>
                </a>
            </div>
            
            <div class="btn btn-github">
                <a href="https://github.com/2585479524" target="_blank" title="github" ref="friend">
                    <i class="fa fa-github"></i>
                </a>
            </div>
            
        </div>
    </div>
</div>
            <div class="page-title">
    <ul>
        <li><a href="/">最新</a></li>
        
            
                <li class="">
                    <a href="/categories/big-front-end" data-name="前端">前端</a>
                </li>
            
                <li class="active">
                    <a href="/categories/serverSide" data-name="后端">后端</a>
                </li>
            
                <li class="">
                    <a href="/categories/unity" data-name="Unity">Unity</a>
                </li>
            
                <li class="">
                    <a href="/categories/resource" data-name="曾经沧海">曾经沧海</a>
                </li>
            
        
        <li class="page-search">
    <form id="search" class="search-form">
        <label for="s" class="sr-only">请输入关键字</label>
        <input class="search-field" type="text" name="s" class="text" placeholder="请输入关键字" />
        <button type="submit" class="search-form-submit" title="搜索"><i class="fa fa-search"></i></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
</li>

    </ul>
</div>
<div class="main-inner">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
        <div class="post-header">
            <div class="post-author clearfix">
                <a class="avatar fleft" href="" target="_blank">
                    <img width="48" src="/images/favicon.png" alt="avatar"/>
                </a>
                <p><span class="label">作者</span>
                    <a href="" target="_blank">牧</a>
                    <span title="最后编辑于2018-05-05">2018-05-05</span>
                </p>
                <p>会点前端的游戏开发者</p>
            </div>
            <h2 class="post-title">深入浅出讲算法思想--贪婪法思想分析及应用</h2>
            <div class="post-meta">
                本文总共16787个字 | 您是第<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>位看到它们的小伙伴
            </div>
        </div>
        <div class="post-content markdown-body">
            <h2 id="贪婪算法："><a href="#贪婪算法：" class="headerlink" title="贪婪算法："></a>贪婪算法：</h2><p>通过一系列步骤来构造问题的解，每一步对目前构造的部分分解做一个拓展，直到获得问题的完整解为止,而算法的核心思想就在于，算法的每一步都必须满足以下条件：可行（满足问题的约束条件）、局部最优（当前步骤所有可行选择中的局部最优解）、不可取消（一旦选择，在后续步骤中不可改变）。</p>
<ol>
<li>贪婪算法在求解最小生成树中的应用–Prim算法、Kruskal算法</li>
<li>贪婪算法在求解最短路径中的应用–Dijkstra算法</li>
<li>贪婪算法在解决哈夫曼树及编码问题中的应用</li>
</ol>
<h2 id="一、贪婪算法在求解最小生成树中的应用–Prim算法、Kruskal算法"><a href="#一、贪婪算法在求解最小生成树中的应用–Prim算法、Kruskal算法" class="headerlink" title="一、贪婪算法在求解最小生成树中的应用–Prim算法、Kruskal算法"></a>一、贪婪算法在求解最小生成树中的应用–Prim算法、Kruskal算法</h2><p>感兴趣的读者可以先参考<a href="/2018/05/05/graph4InJava">图论算法(四)–最小生成树的Kruskal [ 加边 ] 、Prim [ 加点 ] 的解法(JAVA)</a>这篇文章</p>
<p>对于连通图来说生成树定义为包含图中所有顶点的连通无环子图</p>
<p>而在加权连通图中权重最小的生成树被称为最小生成树</p>
<p><strong>1. Prim算法</strong>被又称为“加点法”,我们从图中的顶点集合中任意选择一个顶点作为序列的初始子树，每次迭代的时候，以贪婪的方式扩张生成树，该算法每次只扩展一个点，迭代的总次数为n-1。所以这就要求对于每个不在树中的顶点，必须知道它连接树中顶点的最短边信息。我们可以给一个顶点附加两个标记：树中最近顶点的名称以及对应边的长度。对于任意加入生成树中的顶点来说，我们要做两步，操作一：将该顶点从集合V-Vt 移动带顶点集合Vt中，操作二：对V-Vt中的每个顶点更新。</p>
<p>我们以下面这个图为例子讲解Prim算法的过程：</p>
<p><img src="/img/2018/greedySummaryInJava/1.png" alt="示意图"><br><img src="/img/2018/greedySummaryInJava/2.png" alt="示意图"></p>
<p>Input:</p>
<p>6 10<br>1 2 3<br>1 5 6<br>1 6 5<br>2 6 5<br>2 3 1<br>3 6 4<br>3 4 6<br>4 6 5<br>4 5 8</p>
<p>5 6 2</p>
<p>Output:</p>
<p>15</p>
<p>完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    static int[][] e = new int[7][7];</span><br><span class="line">    static int[] book = new int[7];</span><br><span class="line">    static int[] dis = new int[7];</span><br><span class="line">    static int count = 0;</span><br><span class="line">    static int sum = 0;</span><br><span class="line">    static int n, m;</span><br><span class="line">    static int min, mark;</span><br><span class="line">    static Scanner input = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        n = input.nextInt();</span><br><span class="line">        m = input.nextInt();</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">                if (i == j) &#123;</span><br><span class="line">                    e[i][j] = 0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    e[i][j] = 99999999;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">            int a = input.nextInt();</span><br><span class="line">            int b = input.nextInt();</span><br><span class="line">            int c = input.nextInt();</span><br><span class="line">            e[a][b] = c;</span><br><span class="line">            e[b][a] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            dis[i] = e[1][i];</span><br><span class="line">        &#125;</span><br><span class="line">        book[1] = 1;</span><br><span class="line"></span><br><span class="line">        prime();</span><br><span class="line"></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void prim() &#123;</span><br><span class="line">        count++;</span><br><span class="line">        while (count &lt; n) &#123;</span><br><span class="line">            min = 99999999;</span><br><span class="line">            for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">                if (book[i] == 0 &amp;&amp; dis[i] &lt; min) &#123;</span><br><span class="line">                    min = dis[i];</span><br><span class="line">                    mark = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            book[mark] = 1;</span><br><span class="line">            count++;</span><br><span class="line">            sum += dis[mark];</span><br><span class="line">            for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">                if (book[i] == 0 &amp;&amp; dis[i] &gt; e[mark][i]) &#123;</span><br><span class="line">                    dis[i] = e[mark][i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度O(n^2)，如果采用堆来构造一个优先队列则会使算法的时间复杂度变为O(nlogn)</p>
<p><strong>2. Kruskal算法</strong>又被称为“加边法”，这种算法会将加权连通图的最小生成树看成具有V-1条边的无环子图，且边的权重和最小。算法开始时，会按照权重的非递减顺序对图中的边排序，之后迭代的以贪婪的方式添加边。</p>
<p>下面以下图为例来讲解Kruskal算法的过程：</p>
<p><img src="/img/2018/greedySummaryInJava/3.png" alt="示意图"><br><img src="/img/2018/greedySummaryInJava/4.png" alt="示意图"></p>
<p>Input:</p>
<p>6 10<br>1 2 3<br>1 5 6<br>1 6 5<br>2 6 5<br>2 3 1<br>3 6 4<br>3 4 6<br>4 6 5<br>4 5 8</p>
<p>5 6 2</p>
<p>Output:</p>
<p>15</p>
<p>完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">class edge &#123;</span><br><span class="line">    int u, v, w;</span><br><span class="line">    edge(int u, int v, int w) &#123;</span><br><span class="line">        this.u = u;</span><br><span class="line">        this.v = v;</span><br><span class="line">        this.w = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    static edge[] e = new edge[11];</span><br><span class="line">    static int n, m;</span><br><span class="line">    static int[] f = new int[7];</span><br><span class="line">    static int sum = 0;</span><br><span class="line">    static int count = 0;</span><br><span class="line">    static Scanner input = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        n = input.nextInt();</span><br><span class="line">        m = input.nextInt();</span><br><span class="line">        for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">            int a = input.nextInt();</span><br><span class="line">            int b = input.nextInt();</span><br><span class="line">            int c = input.nextInt();</span><br><span class="line">            e[i] = new edge(a, b, c);</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">         * 按权值排序</span><br><span class="line">         * */</span><br><span class="line">        quicksort(e, 1, m);</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            f[i]  = i;</span><br><span class="line">        &#125;</span><br><span class="line">        kruskal();</span><br><span class="line"></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void kruskal() &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 从小到大枚举每一条边</span><br><span class="line">         * */</span><br><span class="line">        for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 检查一条边的两个顶点是否已经连通，即判断是否在同一个集合中</span><br><span class="line">             * */</span><br><span class="line">            if (merge(e[i].u, e[i].v)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                sum = sum + e[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">            /**</span><br><span class="line">             * 选到n-1边之后，退出循环</span><br><span class="line">             * */</span><br><span class="line">            if (count == n - 1) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int partition(edge[] a, int p, int q) &#123;</span><br><span class="line">        int x = a[p].w;</span><br><span class="line">        int i = p;</span><br><span class="line">        for (int j = p+1; j &lt;= q; j++) &#123;</span><br><span class="line">            if (a[j].w &lt;= x) &#123;</span><br><span class="line">                i += 1;</span><br><span class="line">                edge temp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        edge temp = a[p];</span><br><span class="line">        a[p] = a[i];</span><br><span class="line">        a[i] = temp;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void quicksort(edge[] a,int p, int q) &#123;</span><br><span class="line">        if (p &lt; q) &#123;</span><br><span class="line">            int r = partition(a ,p ,q);</span><br><span class="line"></span><br><span class="line">            quicksort(a, p, r - 1);</span><br><span class="line">            quicksort(a, r + 1, q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getf(int v) &#123;</span><br><span class="line">        if (f[v] == v) &#123;</span><br><span class="line">            return v;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 压缩路径，每次函数返回时，将该位置的编号转成祖宗编号</span><br><span class="line">             * */</span><br><span class="line">            f[v] = getf(f[v]);</span><br><span class="line">            return f[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean merge(int v, int u) &#123;</span><br><span class="line">        int t1 = getf(v);</span><br><span class="line">        int t2 = getf(u);</span><br><span class="line">        /**</span><br><span class="line">         * 判断祖先是否相同</span><br><span class="line">         * */</span><br><span class="line">        if (t1 != t2) &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 靠左原则</span><br><span class="line">             * */</span><br><span class="line">            f[t2] = t1;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Kruskal算法的时间复杂度主要取决于对图中的边进行权值排序，如果排序算法效率比较高，那么Kruskal算法的时间复杂度为O(nlogn)</p>
<h2 id="二、贪婪算法在求解最短路径中的应用–Dijkstra算法"><a href="#二、贪婪算法在求解最短路径中的应用–Dijkstra算法" class="headerlink" title="二、贪婪算法在求解最短路径中的应用–Dijkstra算法"></a>二、贪婪算法在求解最短路径中的应用–Dijkstra算法</h2><p>最短路径问题最经典的算法就是Dijkstra算法，虽然不如Floyd算法能够求全源的最短路径，但是在效率上明显强于Floyd算法。</p>
<p>想了解Floyd算法的读者可以参考<a href="/2018/05/05/dpSummaryInJava">深入浅出讲算法思想–动态规划思想分析及应用</a></p>
<p>单源最短路径问题是对于加权连通图来说，我们给定一个起点，求出它到其他顶点之间的一系列最短路径。这个问题不同于从一个起点出发访问其他所有顶点的问题（TSP问题），这种问题所求的一组路径都是从起点出发通向图中的一个不同顶点。这些路径中可能存在公共边。</p>
<p>Dijkstra算法和Prim算法的用法比较相似，二者都是从顶点集中选择一个顶点来构造树，但是解决的问题是不同的。Dijkstra算法每次比较的是路径的总长度，每次要把权重相加。而Prim算法则直接比较权重。</p>
<p>以下图的例子来描述Dijkstra算法的过程：</p>
<p><img src="/img/2018/greedySummaryInJava/5.png" alt="示意图"></p>
<p>Input:</p>
<p>5 7<br>1 2 3<br>1 4 7<br>2 4 2<br>2 3 4<br>3 4 5<br>3 5 6<br>4 5 4</p>
<p>Output:</p>
<p>0 3 7 5 9 </p>
<p>完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    static int[][] e = new int[10][10];</span><br><span class="line">    static int[] book = new int[10];</span><br><span class="line">    static int[] dis = new int[10];</span><br><span class="line">    static int n, m;</span><br><span class="line">    static int min = 99999999;</span><br><span class="line">    static int mark = 0;</span><br><span class="line">    static Scanner input = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        n = input.nextInt();</span><br><span class="line">        m = input.nextInt();</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">                if (i == j) &#123;</span><br><span class="line">                    e[i][j] = 0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    e[i][j] = 99999999;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">            int a = input.nextInt();</span><br><span class="line">            int b = input.nextInt();</span><br><span class="line">            int c = input.nextInt();</span><br><span class="line">            e[a][b] = c;</span><br><span class="line">            e[b][a] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">         * 1到其他各点的距离</span><br><span class="line">         * */</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            dis[i] = e[1][i];</span><br><span class="line">        &#125;</span><br><span class="line">        book[1] = 1;</span><br><span class="line"></span><br><span class="line">        dijkstra();</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            System.out.print(dis[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void dijkstra() &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 遍历n-1次，每次找出一个 1到某个点的最短距离</span><br><span class="line">         * */</span><br><span class="line">        for (int i = 1; i &lt;= n-1; i++) &#123;</span><br><span class="line">            min = 99999999;</span><br><span class="line">            /**</span><br><span class="line">             * 选出离1号点最近的顶点</span><br><span class="line">             * */</span><br><span class="line">            for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">                if (book[j] == 0 &amp;&amp; dis[j] &lt; min) &#123;</span><br><span class="line">                    min = dis[j];</span><br><span class="line">                    mark = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            book[mark] = 1;</span><br><span class="line">            /**</span><br><span class="line">             * 松弛</span><br><span class="line">             * */</span><br><span class="line">            for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">                if (e[mark][j] &lt; 99999999) &#123;</span><br><span class="line">                    if (dis[j] &gt; dis[mark] + e[mark][j]) &#123;</span><br><span class="line">                        dis[j] = dis[mark] + e[mark][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度：O(nlogn)，当然如果能够采用邻接表存储数据会更快。</p>
<h2 id="三、贪婪算法在解决哈夫曼树及编码问题中的应用"><a href="#三、贪婪算法在解决哈夫曼树及编码问题中的应用" class="headerlink" title="三、贪婪算法在解决哈夫曼树及编码问题中的应用"></a>三、贪婪算法在解决哈夫曼树及编码问题中的应用</h2><p>哈夫曼编码，是一种可变字长编码(VLC)的高效算法。该算法是Huffman于1952年提出一种编码方法，该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码。</p>
<p>相比定长编码来说，这种编码实现的压缩率（衡量压缩算法效率的重要指标）非常高，也就是说，哈夫曼编码比定长编码占用更少的存储空间。</p>
<p>假设我们要对某个字母表创建一套二进制前缀码，那么我们一般都会讲字母表中的字符与二进制的叶子联系起来，树中所有的左向边都为0，右向边都为1.可以通过记录根到字符叶子的简单路径上的标记来获得一个字符的代码字。这样任何一棵这样的树都可以生成一套前缀码。但是我们都知道即使在英文单词中，每个字母出现的概率都是不同的，如果仅仅是放到二叉树中，对于一些高频字符很可能需要更长的代码串来表示，这是非常不友好的。</p>
<p>一个方法就是通过根据字符出现的概率，尽可能将短位串分配给高频字符，长位串分配给低频字符。这里就用到了贪婪思想。</p>
<p>思路：</p>
<ol>
<li><p>初始化n个单节点的数，表上字母表中的字符，并将其概率记录，用来表示权重。</p>
</li>
<li><p>找出两颗权重最小的树（对于权重都相同的树，任选其一），将它们作为新树中的左右子树，并将权值之和记录到新的树根中。迭代这一步操作，直到剩下一棵单独的树。</p>
</li>
</ol>
<p>以下面的例子来描述哈夫曼树的构造过程：</p>
<p><img src="/img/2018/greedySummaryInJava/6.png" alt="示意图"></p>
<p>由上面的过程我们得到了下面的代码字：<br><img src="/img/2018/greedySummaryInJava/7.png" alt="示意图"></p>
<p><img src="/img/2018/greedySummaryInJava/8.png" alt="示意图"></p>
<p>Input:</p>
<p>5</p>
<p>A B C D _</p>
<p>35 10 20 20 15</p>
<p>Output:</p>
<p>A : 11</p>
<p>B : 100</p>
<p>C : 00</p>
<p>D : 01</p>
<p>_ : 101</p>
<p>完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    //建立数的节点类</span><br><span class="line">    static class Node&#123;</span><br><span class="line">        int weight;//频数</span><br><span class="line">        int parent;</span><br><span class="line">        int leftChild;</span><br><span class="line">        int rightChild;</span><br><span class="line"></span><br><span class="line">        public Node(int weight, int parent, int leftChild, int rightChild)&#123;</span><br><span class="line">            this.weight = weight;</span><br><span class="line">            this.parent = parent;</span><br><span class="line">            this.leftChild = leftChild;</span><br><span class="line">            this.rightChild = rightChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void setWeight(int weight)&#123;</span><br><span class="line">            this.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void setParent(int parent)&#123;</span><br><span class="line">            this.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void setLeftChild(int leftChild)&#123;</span><br><span class="line">            this.leftChild = leftChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void setRightChild(int rightChild)&#123;</span><br><span class="line">            this.rightChild = rightChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int getWeight()&#123;</span><br><span class="line">            return weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int getParent()&#123;</span><br><span class="line">            return parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int getLeftChild()&#123;</span><br><span class="line">            return leftChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int getRightChild()&#123;</span><br><span class="line">            return rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //新建哈夫曼编码</span><br><span class="line">    static class NodeCode &#123;</span><br><span class="line">        String character;</span><br><span class="line">        String code;</span><br><span class="line">        NodeCode(String character, String code) &#123;</span><br><span class="line">            this.character = character;</span><br><span class="line">            this.code = code;</span><br><span class="line">        &#125;</span><br><span class="line">        NodeCode(String code) &#123;</span><br><span class="line">            this.code = code;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void setCharacter(String character) &#123;</span><br><span class="line">            this.character = character;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void setCode(String code) &#123;</span><br><span class="line">            this.code = code;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String getCharacter() &#123;</span><br><span class="line">            return character;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String getCode() &#123;</span><br><span class="line">            return code;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化一个哈弗曼树</span><br><span class="line">    public static void initHuffmanTree(Node[] huffmanTree, int m)&#123;</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            huffmanTree[i] = new Node(0, -1, -1, -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化编码</span><br><span class="line">    public static void initHuffmanCode(NodeCode[] huffmanCode, int n)&#123;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            huffmanCode[i] = new NodeCode(&quot;&quot;,&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取huffmanCode的符号</span><br><span class="line">    public static void getHuffmanCode(NodeCode[] huffmanCode, int n)&#123;</span><br><span class="line">        Scanner input = new Scanner(System.in);</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            String temp = input.next();</span><br><span class="line">            huffmanCode[i] = new NodeCode(temp,&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取频率</span><br><span class="line">    public static void getHuffmanWeight(Node[] huffmanTree , int n)&#123;</span><br><span class="line">        Scanner input = new Scanner(System.in);</span><br><span class="line">        for(int i = 0; i &lt; n;i ++)&#123;</span><br><span class="line">            int temp = input.nextInt();</span><br><span class="line">            huffmanTree[i] = new Node(temp, -1, -1, -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //选取两个较小的结点</span><br><span class="line">    public static int[] selectMin(Node[] huffmanTree ,int n) &#123;</span><br><span class="line">        int min[] = new int[2];</span><br><span class="line">        class TempNode &#123;</span><br><span class="line">            int newWeight;//存储权</span><br><span class="line">            int place;//存储该结点所在的位置</span><br><span class="line"></span><br><span class="line">            TempNode(int newWeight, int place)&#123;</span><br><span class="line">                this.newWeight = newWeight;</span><br><span class="line">                this.place = place;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            void setNewWeight(int newWeight)&#123;</span><br><span class="line">                this.newWeight = newWeight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            void setPlace(int place)&#123;</span><br><span class="line">                this.place = place;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int getNewWeight()&#123;</span><br><span class="line">                return newWeight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int getPlace()&#123;</span><br><span class="line">                return place;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TempNode[] tempTree = new TempNode[n];</span><br><span class="line"></span><br><span class="line">        //将huffmanTree中没有双亲的结点存储到tempTree中</span><br><span class="line">        int i=0,j=0;</span><br><span class="line">        for(i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if(huffmanTree[i].getParent() == -1 &amp;&amp; huffmanTree[i].getWeight()!=0) &#123;</span><br><span class="line">                tempTree[j] = new TempNode(huffmanTree[i].getWeight(),i);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int m1,m2;</span><br><span class="line">        m1 = m2 = 0;</span><br><span class="line">        for(i = 0; i &lt; j; i++) &#123;</span><br><span class="line">            if(tempTree[i].getNewWeight() &lt; tempTree[m1].getNewWeight())//此处不让取到相等，是因为结点中有相同权值的时候，m1取最前的</span><br><span class="line">                m1 = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(i = 0; i &lt; j; i++) &#123;</span><br><span class="line">            if(m1 == m2)</span><br><span class="line">                m2++;//当m1在第一个位置的时候，m2向后移一位</span><br><span class="line">            if(tempTree[i].getNewWeight() &lt;= tempTree[m2].getNewWeight() &amp;&amp; i != m1)//此处取到相等，是让在结点中有相同的权值的时候，</span><br><span class="line"></span><br><span class="line">                //m2取最后的那个。</span><br><span class="line">                m2 = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        min[0] = tempTree[m1].getPlace();</span><br><span class="line">        min[1] = tempTree[m2].getPlace();</span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建哈弗曼树</span><br><span class="line">    public static void createHaffmanTree(Node[] huffmanTree,int n)&#123;</span><br><span class="line">        if(n &lt;= 1)</span><br><span class="line">            System.out.println(&quot;Parameter Error!&quot;);</span><br><span class="line">        int m = 2 * n - 1;</span><br><span class="line">        //initHuffmanTree(huffmanTree,m);</span><br><span class="line"></span><br><span class="line">        for(int i = n; i &lt; m; i++) &#123;</span><br><span class="line">            int[] min = selectMin(huffmanTree, i);</span><br><span class="line">            int min1 = min[0];</span><br><span class="line">            int min2 = min[1];</span><br><span class="line">            huffmanTree[min1].setParent(i);</span><br><span class="line">            huffmanTree[min2].setParent(i);</span><br><span class="line">            huffmanTree[i].setLeftChild(min1);</span><br><span class="line">            huffmanTree[i].setRightChild(min2);</span><br><span class="line">            huffmanTree[i].setWeight(huffmanTree[min1].getWeight() + huffmanTree[min2].getWeight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建哈夫曼编码</span><br><span class="line">    public static void createHaffmanCode(Node[] huffmanTree,NodeCode[] huffmanCode,int n)&#123;</span><br><span class="line">        Scanner input = new Scanner(System.in);</span><br><span class="line">        char[] code = new char[10];</span><br><span class="line">        int start;</span><br><span class="line">        int c;</span><br><span class="line">        int parent;</span><br><span class="line">        int temp;</span><br><span class="line"></span><br><span class="line">        code[n-1] = &apos;0&apos;;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">            start = n-1;</span><br><span class="line">            c = i;</span><br><span class="line">            while((parent=huffmanTree[c].getParent()) &gt;= 0)</span><br><span class="line">            &#123;</span><br><span class="line">                start--;</span><br><span class="line">                code[start] = ((huffmanTree[parent].getLeftChild() == c) ? &apos;0&apos; : &apos;1&apos;);</span><br><span class="line">                c = parent;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            for(;start &lt; n-1; start++)&#123;</span><br><span class="line">                stringBuffer.append(code[start]);</span><br><span class="line">            &#125;</span><br><span class="line">            huffmanCode[i].setCode(stringBuffer.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //输出</span><br><span class="line">    public static void ouputHaffmanCode(NodeCode[] huffmanCode,int n)&#123;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            System.out.println(huffmanCode[i].getCharacter() + &quot; : &quot; + huffmanCode[i].getCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //主函数</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner input = new Scanner(System.in);</span><br><span class="line">        int n;</span><br><span class="line">        int m;</span><br><span class="line">        n = input.nextInt();</span><br><span class="line">        m = 2*n-1;</span><br><span class="line">        Node[] huffmanTree = new Node[m];</span><br><span class="line">        NodeCode[] huffmanCode = new NodeCode[n];</span><br><span class="line"></span><br><span class="line">        //初始化</span><br><span class="line">        initHuffmanTree(huffmanTree, m);</span><br><span class="line">        initHuffmanCode(huffmanCode, n);</span><br><span class="line"></span><br><span class="line">        //获取符号</span><br><span class="line">        getHuffmanCode(huffmanCode, n);</span><br><span class="line"></span><br><span class="line">        //获取概率</span><br><span class="line">        getHuffmanWeight(huffmanTree, n);</span><br><span class="line"></span><br><span class="line">        //创建哈夫曼树</span><br><span class="line">        createHaffmanTree(huffmanTree, n);</span><br><span class="line">        //创建哈夫曼编码</span><br><span class="line">        createHaffmanCode(huffmanTree, huffmanCode, n);</span><br><span class="line"></span><br><span class="line">        //输出</span><br><span class="line">        ouputHaffmanCode(huffmanCode, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：输出哈夫曼树和输出哈夫曼编码时不同的操作。</p>

        </div>
        <div class="post-tool">
            <a class="btn-thumbs-up" href="javascript:void(0);" data-cid="52" title="95">
                <i class="fa fa-thumbs-up" aria-hidden="true"></i> 打赏
            </a>
        </div>
        
        <div class="post-tags">标签：
            
            <a href="/tags/算法思想/">算法思想</a>
            
        </div>
        
    </article>
    
    <p>文章为原创作品，转发请留言</p>
    
    
</div>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        </div><!-- end #main-->
    </div><!-- end #body -->
    <footer class="footer">
    <div class="footer-inner">
        <p>
            <a href="/about"  title="关于本站">关于本站</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <!-- 自定义链接 -->
            <a href="/help" title="help" >急救中心</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/links" title="友情链接">友情链接</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/app" title="App下载">App下载</a>
        </p>
        <p>
            本站点采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>，已建立<a href="/timeline" id="siteBuildingTime"></a>天<br/>
            ©2017 基于<a href="http://hexo.io" target="_blank">Hexo</a>搭建
            ，主题&nbsp<a href="https://github.com/tangkunyin/hexo-theme-jsimple" target="_blank">JSimple</a>
            ，作者<a href="https://www.tangkunyin.com" target="_blank">唐先森</a>
            ，Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>
        </p>
        
<!-- Tencent Analytics -->
<script type="text/javascript" src="//tajs.qq.com/stats?sId=65823874" charset="UTF-8"></script>


    </div>
</footer>
<script src="https://cdn.bootcss.com/jquery/3.1.1/jquery.js"></script>
<script src="/js/InsightSearch.js"></script>
<script src="/js/SimpleCore.js"></script>

</div>
<div class="fixed-btn">
    <a class="btn-gotop" href="javascript:"> <i class="fa fa-angle-up"></i></a>
</div>
<script>
    $(function () {
        SimpleCore.init({
            buildingTime: '01/26/2018',
            current: $('.post-tags').length > 0 ? 'post' : 'archive',
            snsQRCode: '/images/sns-qrcode.png',
            donateImg: '/images/donate-qr.png',
        });
    });
</script>
</body>
</html>
